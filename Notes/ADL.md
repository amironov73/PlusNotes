### ADL

https://habr.com/ru/post/470265/

*Argument-Dependent Lookup. Поиск, зависящий от аргументов.* Он же поиск Кёнига — в честь Andrew Koenig. Это набор правил для разрешения неквалифицированных имен функций (т. е. имен без оператора ::), дополнительный к обычному разрешению имен. Упрощенно: имя функции ищется в пространствах имен, относящихся к ее аргументам (это пространство, содержащее тип аргумента, сам тип, если это класс, все его предки и т.п.).

Простейший пример

```c++
#include <iostream>

namespace N
{
    struct S {};
    void f(S) { std::cout << "f(S)" << std::endl; };
}

int main()
{
    N::S s;
    f(s);
}
```

Функция f найдена в пространстве имен N только потому, что ее аргумент принадлежит этому пространству.

Даже банальный `std::cout << "Hello World!\n"` использует ADL, т. к. `std::basic_stream::operator<<` не перегружен для `const char*`. Но первым аргументом этого оператора является `std::basic_stream`, и компилятор ищет и находит подходящую перегрузку в пространстве имен `std`.

Некоторые детали: ADL не применяется, если обычный поиск нашел объявление члена класса, или объявление функции в текущем блоке без использования `using`, или объявление не функции и не шаблона функции. Или если имя функции указано в скобках (пример выше не скомпилируется с `(f)(s)`; придется писать `(N::f)(s);)`.

Иногда ADL заставляет использовать полные квалифицированные имена функций там, где это, казалось бы, излишне.

Например, этот код не скомпилируется

```c++
namespace N1
{
    struct S {};
    void foo(S) {};
}

namespace N2
{
    void foo(N1::S) {};
    void bar(N1::S s) { foo(s); }
}
```
