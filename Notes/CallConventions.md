### Соглашения о вызове

Соглашение о вызове (англ. calling convention)  — описание технических особенностей вызова подпрограмм, определяющее:

* способы передачи параметров подпрограммам;
* способы вызова (передачи управления) подпрограмм;
* способы передачи результатов вычислений, выполненных подпрограммами, в точку вызова;
* способы возврата (передачи управления) из подпрограмм в точку вызова.

#### Microsoft

* **\_\_cdecl** - соглашение о вызовах, используемое компиляторами для языка Си (отсюда название).

    Рассмотрим на примере x86. Аргументы функций передаются через стек, справа налево. Аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт. Очистку стека производит вызывающая программа. Это основной способ вызова функций с переменным числом аргументов (например, printf()). Способы получения возвращаемого значения функции приведены в таблице.

Тип                      | Размер возвращаемого значения, байт | Способ передачи возвращаемого значения | Примечания
-------------------------|-------------------------------------|----------------------------------------|-----------
Целое число, указатель   | 1, 2, 4                             | Регистр EAX                            | Значения, размер которых меньше 4-х байт, расширяются до 4-х байт
Целое число              | 8                                   | Через пару регистров EDX:EAX           |
Число с плавающей точкой | 4, 8                                | Регистр ST0                            |
Другие                   | Больше 8                            | Регистр EAX                            | Указатель на структуру данных сохраняется в регистре eax
 
Перед вызовом функции вставляется код, называемый прологом (англ. prolog) и выполняющий следующие действия:
     
* сохранение значений регистров, используемых внутри функции: EAX, ECX и EDX сохраняет вызывающая сторона, остальные - вызываемая;
* запись в стек аргументов функции.
     
После вызова функции вставляется код, называемый эпилогом (англ. epilog) и выполняющий следующие действия:
     
* восстановление значений регистров, сохранённых кодом пролога;
* очистка стека (от локальных переменных функции).

Пусть у нас есть пара функций

```c
int __cdecl callee(int, int, int);

int __cdecl caller(void)
{
    return callee(1, 2, 3) + 5;
}
```

Вот во что будет скомпилирован Visual C++ (без оптимизации):

```asm
callee PROC
    push    ebp
    mov     ebp, esp
    mov     eax, DWORD PTR [ebp + 4]  ; x
    add     eax, DWORD PTR [ebp + 8]  ; y
    add     eax, DWORD PTR [ebp + 12] ; z
    pop     ebp
    ret     0
callee ENDP

caller PROC
    push    ebp
    mov     ebp, esp
    push    3 ; z
    push    2 ; y
    push    1 ; x
    call    callee
    add     esp, 12
    add     eax, 4
    pop     ebp
    ret     0
caller ENDP
```

Пример функции-члена:

```c++
struct MyClass {
   void __cdecl myMethod();
};
...
void __cdecl CMyClass::myMethod() 
{ 
    return; 
}
```

* **\_\_clrcall** - указывает, что функция может быть вызвана только из управляемого кода. Модификатор __clrcall специфичен для Microsoft.

* **\_\_fastcall** - общее название соглашений, передающих параметры через регистры (обычно это самый быстрый способ, отсюда название). Если для сохранения всех параметров и промежуточных результатов регистров не достаточно, используется стек.
                     
Соглашение о вызовах fastcall не стандартизировано, поэтому используется только для вызова процедур и функций, не экспортируемых из исполняемого модуля и не импортируемых извне.
                     
В компиляторах фирмы Borland для соглашения \_\_fastcall, называемого также register, параметры передаются слева направо в регистрах EAX, EDX, ECX, а если параметров больше трёх — в стеке, также слева направо. Исходное значение указателя на вершину стека (значение регистра esp) возвращает вызываемая подпрограмма.
                     
В 32-разрядной версии компилятора фирмы Microsoft, а также в компиляторе GCC, соглашение \_\_fastcall, также называемое \_\_msfastcall, определяет передачу первых двух параметров слева направо в регистрах ECX и EDX, а остальные параметры передаются справа налево в стеке. Очистку стека производит вызываемая подпрограмма.

```c++
struct MyClass {
   void __fastcall myMethod();
};
...
void __fastcall CMyClass::myMethod() 
{ 
    return; 
}
```

* **\_\_stdcall** или **winapi** - соглашение о вызовах, применяемое в ОС Windows для вызова функций WinAPI.
                    
Аргументы функций передаются через стек, справа налево. Очистку стека производит вызываемая подпрограмма.

```c++
struct MyClass {
   void __stdcall myMethod();
};
...
void __stdcall CMyClass::myMethod() 
{ 
    return; 
}
```

* **\_\_thiscall** - это соглашение о вызовах используется для вызова нестатических функций-членов C++. В зависимости от компилятора и от того, использует ли функция переменное число аргументов, используются две основные версии этого вызова.
                     
Для компилятора GCC этот вызов почти идентичен cdecl: вызывающая сторона очищает стек, а параметры передаются в порядке справа налево. Разница заключается в добавлении указателя this, который помещается в стек последним, как если бы это был первый параметр в прототипе функции.
                     
В компиляторе Microsoft Visual C++ этот указатель передается в ECX, и именно вызываемый объект очищает стек, отражая соглашение stdcall, используемое в C для этого компилятора и в функциях API Windows. Когда функции используют переменное число аргументов, чистящий стек очищает вызывающая программа.
                     
Соглашение о вызовах thiscall может быть явно указано только в Microsoft Visual C++ 2005 и более поздних версиях. На любом другом компиляторе thiscall не является ключевым словом.

* **\_\_vectorcall** - В Visual Studio 2013 Microsoft представила соглашение о вызовах \_\_vectorcall в ответ на запросы со стороны разработчиков игр, графики, видео/аудио и кодеков. Схема позволяет передавать в регистр большие векторные типы (float, double, __m128, __m256), а не в стек.
                       
Для кода IA-32 и x64 \_\_vectorcall аналогичен \_\_fastcall и исходным соглашениям о вызовах x64 соответственно, но расширяет их для поддержки передачи векторных аргументов с использованием регистров SIMD. В IA-32 целочисленные значения передаются как обычно, и первые шесть регистров SIMD (XMM / YMM0-5) содержат до шести значений с плавающей запятой, вектора или значения HVA последовательно слева направо, независимо от фактических вызванных положений например, между ними появляется аргумент int. В x64, однако, правило из исходного соглашения x64 все еще применяется, так что XMM / YMM0-5 содержат аргументы с плавающей точкой, вектор или HVA только тогда, когда они оказываются с первого по шестой.
                       
\_\_vectorcall добавляет поддержку для передачи значений однородного векторного агрегата (HVA), которые являются составными типами (структурами), состоящими только из четырех идентичных векторных типов, с использованием одних и тех же шести регистров. Как только регистры назначены для аргументов векторного типа, неиспользуемые регистры назначаются для аргументов HVA слева направо. Правила позиционирования все еще применяются. Результирующий тип вектора и значения HVA возвращаются с использованием первых четырех регистров XMM / YMM.
                       
Компилятор clang и компилятор Intel C ++ также реализуют vectorcall. Компилятор Intel C++ имел похожее, более раннее соглашение, называемое \_\_regcall; он также поддерживается clang.
