### RAII

https://habr.com/ru/post/470265/

* Resource Acquisition Is Initialization. Захват ресурса есть инициализация.* Смысл этой идиомы в том, что удержание некоторого ресурса длится в течении жизни соответствующего объекта. Захват ресурса происходит в момент создания/инициализации объекта, освобождение — в момент разрушения/финализации этого же объекта.

Как ни странно (в первую очередь для программистов на C++), эта идиома используется и в других языках, даже в тех, где существует сборщик мусора. В Java это `try`-с-ресурсами, в Python – оператор `with`, в C# – директива `using`, в Go – `defer`. Но именно в C++ с его абсолютно предсказуемой жизнью объектов RAII вписывается особенно органично.

В C++ обычно ресурс захватывается в конструкторе и освобождается в деструкторе. Например, умные указатели так управляют памятью, файловые потоки — файлами, локи мьютексов — мьютексами. Прелесть в том, что независимо от того, как происходит выход из блока (scope) – нормально ли через любую из точек выхода, или было брошено исключение — управляющий ресурсом объект, созданный в этом блоке, будет уничтожен, а ресурс — освобожден. Т.е. помимо инкапсуляции RAII в C++ еще и помогает обеспечивать безопасность в смысле исключений.

Ограничения, куда же без них. Деструкторы в C++ не возвращают значений и категорически не должны бросать исключения. Соответственно, если освобождение ресурса сопровождается тем или другим, придется реализовать дополнительную логику в деструкторе управляющего объекта.
