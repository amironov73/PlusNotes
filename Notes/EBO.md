### EBO

https://habr.com/ru/post/470265/

*Empty Base Optimization. Оптимизация пустого базового класса.* Так же может называться *Empty Base Class Optimization (EBCO)*.

Как известно, в C++ размер объекта любого класса не может быть нулем. Иначе сломается вся арифметика указателей, т. к. по одному адресу будет возможно разметить сколько угодно разных объектов. Поэтому даже объекты пустых классов (т. е. классов без единого нестатического поля) имеют какой-то ненулевой размер, который зависит от компилятора и ОС и обычно равен 1.

Таким образом память зря тратится на все объекты пустых классов. Но не объекты их потомков, т. к. в данном случае Стандарт явно делает исключение. Компилятору разрешено не выделять память под пустой базовый класс и экономить таким образом не только 1 байт пустого класса, а все 4 (зависит от платформы), т. к. есть еще и выравнивание.

Пример

```c++
struct Empty {};

struct Foo : Empty
{
    int i;
};

std::cout << sizeof(Empty) << std::endl;    // 1
std::cout << sizeof(Foo) << std::endl;      // 4
std::cout << sizeof(int) << std::endl;      // 4
```

Но т. к. по одному адресу все-таки не могут размещаться разные объекты одного типа, EBO не сработает, если:

* Пустой класс дважды встречается среди предков

  ```c++
  struct Empty {};

  struct Empty2 : Empty {};

  struct Foo : Empty, Empty2
  {
    int i;
  };

  std::cout << sizeof(Empty) << std::endl;    // 1
  std::cout << sizeof(Empty2) << std::endl;   // 1
  std::cout << sizeof(Foo) << std::endl;      // 8
  ```
  
* Первое нестатическое поле является объектом того же пустого класса или его наследника

  ```c++
  struct Empty {};

  struct Foo : Empty
  {
    Empty e;
    int i;
  };

  std::cout << sizeof(Empty) << std::endl;    // 1
  std::cout << sizeof(Foo) << std::endl;      // 8
  ```

В случаях же когда объекты пустых классов являются нестатическими полями, никаких оптимизаций не предусмотрено (это пока, в C++20 появится атрибут `[[no_unique_address]]`). Но тратить по 4 байта (или сколько компилятору надо) на каждое такое поле обидно, поэтому можно самостоятельно «схлопнуть» объекты пустых классов с первым непустым нестатическим полем.

Пример

```c++
struct Empty1 {};
struct Empty2 {};

template <class Member, class ... Empty>
struct EmptyOptimization : Empty ...
{
    Member member;
};

struct Foo
{
    EmptyOptimization<int, Empty1, Empty2> data;
};
```

Странно, но в этом случае размер Foo получается разным у разных компиляторов, у MSVC 2019 это 8, у GCC 8.3.0 это 4. Но в любом случае увеличение числа пустых классов на размер `Foo` не влияет.
