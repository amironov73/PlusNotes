### constexpr

https://en.cppreference.com/w/cpp/language/constexpr

Спецификатор constexpr предназначен для функций/методов или переменных (в т. ч. шаблонных). Был введен в C++11, доработан в C++14.

Спецификатор constexpr указывает компилятору, что данная функция или переменная может быть (но не обязана!) вычислена в момент компиляции (и таким образом превращается в константу) при соблюдении определенных условий.

Для всех:

* все входные параметры/инициализаторы являются константами либо выражаниями, которые могут быть вычислены на этапе компиляции.

Для функции/метода:

* не виртуальная;
* не корутина;
* возвращаемое значение (если есть) должно быть литеральным типом;
* для конструктора/деструктора требуется, чтобы не было виртуального базового класса;
* в теле не должно быть заморочек вроде `goto`, `throw` и т. д.;
* ровно один return, который может содержать только литералы или constexpr-переменные и constexpr-функции.

Для переменных:

* тип должен быть литеральным;
* должна быть немедленно проинициализирована;
* инициализирующее выражение должно быть константным выражением;

Спецификатор constexpr в C++11 для нестатического метода автоматически подразумевает `const`. В C++14 constexpr функции-члены класса не являются константными.

**Важно:** если аргументы функции не могут быть вычислены в compile-time, то ошибки не будет: компилятор сгенерирует код для вычсилений в run-time.

GCC, начиная с версии 4.4, поддерживает constexpr-функции, Clang также поддерживает с версии 2.9, а Visual Studio 2013 не поддерживает.

### constexpr функция

Получается, что в функциях нельзя инициализировать переменные, создавать циклы и конструкции if-else. С одной стороны, эти ограничения сделаны из-за того, что компилятору нужно хоть как-то отслеживать выполнение программы во время компиляции (рекурсию проще прерывать, чем циклы). С другой — писать сложные функции становится проблематично.

Конечно, все равно все эти возможности можно реализовать. Вместо циклов использовать рекурсию, вместо конструкции if-else — оператор «? :», а вместо создания переменных использовать значения функции.

### constexpr переменная

```c++
constexpr int summa (int left, int right)
{
    return left + right;
}

int main()
{
    constexpr int value = summa (5, 25);
}
```

### constexpr конструктор

Позволяет (при константных входных параметрах) переложить инициализацию на compile-time.

Все нестатические члены класса и члены базовых классов должны быть инициализированы каким-либо образом (в конструкторе, используя списки иницилизации или иницилизацией членов класса при объявлении), причем присвоенные им выражения должны содержать только литералы или constexpr-переменные и constexpr-функции.

```c++
#include <iostream>

struct Something
{
    int x;
    int y;

    constexpr Something (int x_, int y_) : x { x_ }, y { y_ } {}
};

int someFunc(int arg)
{
    return arg * 2;
}

int main() 
{
    constexpr Something one (1, 2);
    std::cout << one.x << ", " << one.y << std::endl;

    int x = someFunc (5), y = someFunc (x);
    Something two (x, y);
    std::cout << two.x << ", " << two.y << std::endl;

    return 0;
}
```
