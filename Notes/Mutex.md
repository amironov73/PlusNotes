### Мьютекс

https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81

Мьютекс (англ. mutex, от mutual exclusion — «взаимное исключение») — аналог одноместного семафора, служащий в программировании для синхронизации одновременно выполняющихся потоков.

Мьютекс отличается от семафора тем, что только владеющий им поток может его освободить, т.е. перевести в отмеченное состояние. Мьютексы — это один из вариантов семафорных механизмов для организации взаимного исключения. Они реализованы во многих ОС, их основное назначение — организация взаимного исключения для потоков из одного и того же или из разных процессов.

Мьютексы — это простейшие двоичные семафоры, которые могут находиться в одном из двух состояний — отмеченном или неотмеченном (открыт и закрыт соответственно). Когда какой-либо поток, принадлежащий любому процессу, становится владельцем объекта mutex, последний переводится в неотмеченное состояние. Если задача освобождает мьютекс, его состояние становится отмеченным.

Задача мьютекса — защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. Если другому потоку будет нужен доступ к переменной, защищённой мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.

Цель использования мьютексов — защита данных от повреждения в результате асинхронных изменений (состояние гонки), однако могут порождаться другие проблемы — например взаимная блокировка (клинч).

Win32 API в Windows имеет две реализации мьютексов — собственно мьютексы, имеющие имена и доступные для использования между разными процессами, и критические секции, которые могут использоваться только в пределах одного процесса. Для каждого из этих двух типов мьютексов используются свои функции захвата и освобождения.

Критическая секция в Windows по возможности блокируется без использования вызова режима ядра (аналогично спинлоку), но при невозможности такой блокировки поток запрашивает ядро.

Мьютекс в стандартной библиотеке [Pthreads](Pthread.md) может использоваться в одном процессе или в разных, но в любом случае всем использующим процессам требуется доступ к памяти, в которой он размещён. Такой мьютекс может иметь один из следующих типов:

* **PTHREAD_MUTEX_NORMAL** — нет контроля повторного захвата тем же потоком (англ. thread);
* **PTHREAD_MUTEX_RECURSIVE** — повторные захваты тем же потоком допустимы, ведётся счётчик таких захватов;
* **PTHREAD_MUTEX_ERRORCHECK** — повторные захваты тем же потоком вызывают немедленную ошибку.

Последний стандарт языка Си (ISO/IEC 9899:2011) определяет тип mtx_t и функции для работы с ним, которые должны быть доступны, если макрос `__STDC_NO_THREADS__` не был определён компилятором. Семантика и свойства мьютексов в целом совпадают со стандартом POSIX:

* **mtx_plain** — нет контроля повторного захвата тем же потоком;
* **mtx_recursive** — повторные захваты тем же потоком допустимы, ведётся счётчик таких захватов;
* **mtx_timed** — поддерживается захват мьютекса с тайм-аутом (следует отметить, что, в отличие от стандарта POSIX, поддержка этого свойства мьютекса не является опциональной).

Возможность использования мьютексов в разделяемой памяти различных процессов в стандарте С11 не рассматривается.

Стандарт языка C++11 определяет различные классы мьютексов:

* **mutex** — нет контроля повторного захвата тем же потоком;
recursive_mutex — повторные захваты тем же потоком допустимы, ведётся счётчик таких захватов;
* **timed_mutex** — нет контроля повторного захвата тем же потоком, поддерживается захват мьютекса с тайм-аутом;
* **recursive_timed_mutex** — повторные захваты тем же потоком допустимы, ведётся счётчик таких захватов, поддерживается захват мьютекса с тайм-аутом.

В C++11 мьютексы проживают в `#include <mutex>`:

```c++
class mutex
{
public:    
    mutex() noexcept = default;
    ~mutex() = default;

    mutex (const mutex&) = delete;
    mutex& operator = (const mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    void unlock();
    native_handle_type native_handle();
};

class recursive_mutex
{
public:
    recursive_mutex() = default;
    ~recursive_mutex() = default;

    recursive_mutex (const recursive_mutex&) = delete;
    recursive_mutex& operator = (const recursive_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    void unlock();
    native_handle_type native_handle();
};
```

Следует отметить библиотеку Boost, которая обеспечивает:

* реализацию мьютексов, совместимых по интерфейсу со стандартом C++11 для компиляторов и платформ, которые не поддерживают этот стандарт;
* реализацию дополнительных классов мьютексов: shared_mutex и др., которые позволяют захватывать мьютекс для совместного владения несколькими потоками только для чтения данных.

Для облегчения манипуляций с мьютексами предусмотрены шаблонные классы `lock_guard` и `unique_lock`:

```c++
template <typename Mutex>
class lock_guard
{
public:
    explicit lock_guard (Mutex& m);
    ~lock_guard();

    lock_guard (const lock_guard&) = delete;
    lock_guard& operator = (const lock_guard&) = delete;
};

template <typename Mutex>
class unique_lock
{
public:
    unique_lock() noexcept;
    explicit unique_lock (Mutex& m);
    unique_lock (const unique_lock&) = delete;
    unique_lock& operator = (const unique_lock&) = delete;
    unique_lock (unique_lock&&) noexcept;
    unique_lock& operator = (unique_lock&&) noexcept;
    ~unique_lock();

    template <typename Clock, typename Duration>
	unique_lock (Mutex& m,
        const chrono::time_point <Clock, Duration>& atime);

    template <typename Rep, typename Period>
	unique_lock (Mutex& m,
        const chrono::duration <Rep, Period>& rtime);

    template <typename Clock, typename Duration>
	bool try_lock_until (const chrono::time_point<Clock, Duration>& atime);

    template <typename Rep, typename Period>
	bool try_lock_for (const chrono::duration<Rep, Period>& rtime);

    void lock();
    bool try_lock();
    void unlock();
    Mutex* release() noexcept;
    bool owns_lock() const noexcept;
    explicit operator bool() const noexcept
      { return owns_lock(); }

    Mutex* mutex() const noexcept;
};
```
