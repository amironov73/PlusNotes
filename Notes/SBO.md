### SBO, SOO и SSO

https://habr.com/ru/post/470265/

*Small Buffer/Object/String Optimization. Оптимизация малых буферов/объектов/строк.* Иногда встречается SSO в значении *Small Size Optimization*, но очень редко, поэтому будем считать, что `SSO` – это про строки. `SBO` и `SOO` – просто синонимы, а `SSO` – наиболее известный частный случай.

Все структуры данных, использующие динамическую память, безусловно занимают и какое-то место и на стеке. Хотя бы для того, чтобы хранить указатель на кучу. И суть этих оптимизаций в том, чтобы для достаточно малых объектов не запрашивать память у кучи (что относительно затратно), а размещать их в уже выделенном пространстве стека.

Например, `std::string` можно было бы реализовать так:

Пример

```c++
class string
{
    char* begin_;
    size_t size_;
    size_t capacity_;
};
```

Размер такого класса у меня получается 24 байта (зависит от компилятора и платформы). Т.е. строки не длиннее 24 символов можно было бы размещать на стеке. На самом не до 24, конечно, т. к. надо как-то различать размещение на стеке и в куче. Но вот простейший способ для коротких строк до 8 символов (размер тот же — 24 байта):

Пример

```c++
class string
{
    union Buffer
    {
        char* begin_;
        char local_[8];
    };

    Buffer buffer_;
    size_t _size;
    size_t _capacity;
};
```

Помимо отсутствия аллокаций в куче, есть еще одно преимущество — высокая степень локальности данных. Массив или вектор таких оптимизированных объектов будет действительно занимать лишь непрерывный кусок памяти.

Почти все реализации `std::string` используют SSO и как минимум некоторые реализации `std::function`. А вот `std::vector` никогда не оптимизируется таким образом, т. к. Стандарт требует, чтобы `std::swap` для двух векторов не вызывала копирования или присваивания их элементов, и чтобы все валидные итераторы оставались валидными. SBO не позволит выполнить эти требования (для `std::string` их нет). Зато `boost::container::small_vector`, как легко догадаться, использует SBO.
