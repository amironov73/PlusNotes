### Синтаксис ассемблера

[https://ru.wikipedia.org/wiki/Intel-синтаксис](https://ru.wikipedia.org/wiki/Intel-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81) и [https://ru.wikipedia.org/wiki/AT&T-синтаксис](https://ru.wikipedia.org/wiki/AT%26T-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81)

**Intel-синтаксис** используется в документации Intel, в ассемблерах для MS-DOS и Windows (MASM, TASM, встроенный ассемблер Visual Studio, и т. д.)

Особенности:

* Приёмник находится слева от источника.
* Название регистров зарезервировано (нельзя использовать метки с именами eax, ebx и т. д.). Например, код
  ```asm
  mov eax, ebx
  ```
  пересылает в регистр `eax` значение, содержащееся в `ebx`.

**Отличия AT&T-ассемблера** (gas) от Intel-ассемблера (MASM, TASM, FASM, NASM):

* Комментарий начинается с символа «#», а не «;»; в свою очередь символ «;» разделяет команды и позволяет записывать несколько команд в одной строке.
* Отсутствие префикса операнда указывает на адрес в памяти; поэтому `movl $foo, %eax` помещает адрес переменной `foo` в регистр `%eax`, а `movl foo,%eax` помещает в `%eax` содержимое переменной `foo`.
* Имена регистров начинаются с символа «%», то есть `%eax, %dl`, вместо `eax`, `dl`, и т. д. Это позволяет включать в код внешние переменные C, не опасаясь ошибок и не используя префиксов с подчёркиванием (_). Например: `%eax`, `%ebx`, `%ecx`, `%edx`.
* Размер операнда определяется как суффикс имени инструкции. Суффиксы:
  * **b** (от byte) — операнды размером в 1 байт
  * **w** (от word) — операнды размером в 1 слово (2 байта)
  * **l** (от long) — операнды размером в 4 байта
  * **q** (от quad) — операнды размером в 8 байт
  * **t** (от ten) — операнды размером в 10 байт
  * **o** (от octo) — операнды размером в 16 байт
  ```asm
  movb %al, %ah
  movw %ax, %bx
  movl %ebx, %eax
  ```
* Порядок операндов — вначале источник, затем приёмник, а не наоборот, как в синтаксисе Intel. Например:
  ```asm
  mov eax, ebx (Intel)
  movl %ebx, %eax (AT&T)
  ```
* числовые константы имеют следующую форму записи
  ```asm
  20h (Intel)
  $0x20 (AT&T, знак доллар в начале)

  mov ebx, 10h (Intel)
  movl $0x10, %ebx (AT&T)
  ```
* для записи/считывания значения из определённого адреса в регистр знак доллара отсутствует
  ```asm
  movl 0xffff, %eax
  ```
* сегмент.смещение (только в реальном режиме):
  ```asm
  00:0FFh (Intel)
  00.$0xFF (AT&T)
  ```
* регистр.смещение:
  ```asm
  es:[bx+0x1a] (Intel)
  %es.0x1a(%bx) (AT&T)
  ```
* Указания на индексные методы адресации отличаются тем, что используются круглые, а не квадратные скобки:
  ```asm
  sub eax,[ebx+ecx*4h-20h] (Intel)
  subl -0x20(%ebx,%ecx,0x4),%eax (AT&T)  # вычесть из EAX значение (ECX * 4) + EBX - 32
  ```
* Отличаются мнемоники некоторых команд (например, `cdq` называется `cltd` в AT&T).
* Отличаются команды ассемблера (такие, как объявление констант, резервирование места).
