### GRASP

https://habr.com/ru/post/470317/

*General Responsibility Assignment Software Patterns. Общие шаблоны распределения ответственностей.* Эти девять шаблонов сформулированы в книге Applying UML and Patterns, автор Craig Larman. Каждый шаблон представляет собой типовое решение одной (но довольно общей) проблемы проектирования ПО.

* **Информационный эксперт** *(Information Expert)*. Проблема: каков общий принцип распределения обязанностей между объектами? Решение: назначить обязанность тому, у кого есть информация, требуемая для выполнения этой обязанности.

* **Создатель** *(Creator)*. Проблема: кто должен отвечать за создание нового объекта? Решение: класс B должен создавать экземпляры класса А, если выполняется одно или несколько из условий:
  * класс B агрегирует или содержит экземпляры A
  * B записывает A
  * B активно использует A
  * B обладает данными инициализации A
  
* **Низкая связность** *(Low Coupling)*. Проблема: как снизить влияние изменений? Как повысить возможность повторного использования? Решение: распределить обязанности так, чтобы связанность была низкой. Связанность (coupling) — мера того, насколько жестко соединены элементы, насколько сильно зависят один от другого. Т.е. рекомендуется связывать объекты так, чтобы они знали друг о друге лишь необходимый минимум.

* **Высокое зацепление** *(High Cohesion)*. Проблема: как обеспечить возможность управления сложностью? Решение: распределять обязанности так, чтобы сохранялось высокое зацепление. Высокое зацепление означает, что обязанности одного элемента сфокусированы на одной области.

* **Контроллер** *(Controller)*. Проблема: кто должен отвечать за обработку входных событий? Решение: назначить ответственным класс, который либо представляет всю системы или подсистему в целом (внешний контроллер), либо один конкретный сценарий (контроллер сценария или сессии). При этом контроллер не реализует реакцию на события, он делегирует это соответствующим исполнителям.

* **Полиморфизм** *(Polymorphism)*. Проблема: как обрабатывать различные варианты поведения на основе типа? Решение: если поведение зависит от типа, назначить ответственным тип, реализующий то или иное поведение, доступ к типам осуществлять через обобщенный интерфейс.

* **Чистая выдумка** *(Pure Fabrication)*. Проблема: какой класс должен обеспечить соблюдение принципов проектирования, если существующие не справляются? Решение: создать класс, не имеющий прототипа в предметной области и назначить ему сильно сцепленный набор нужных обязанностей.

* **Перенаправление** *(Indirection)*. Проблема: как распределить обязанности, чтобы избежать прямого связывания в соответствии с Low Coupling? Решение: присвоить обязанности посреднику и заставить другие объекты общаться через него.

* **Устойчивость к изменениям** *(Protected Variations)*. Проблема: как спроектировать объекты и подсистемы так, чтобы изменения в них не оказывали нежелательного влияния на другие элементы? Решение: найти возможные точки неустойчивости и создать вокруг них стабильный интерфейс, общение осуществлять только через такой интерфейс.

Шаблоны GRASP постоянно пересекаются с шаблонами Банды Четырех и принципами SOLID. Это нормально, т. к. все они решают общую задачу — упростить создание качественного ПО.
