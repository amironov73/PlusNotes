### ODR

https://habr.com/ru/post/470265/

*One Definition Rule. Правило одного определения.* Упрощенно означает следующее:

* В пределах одной единицы трансляции каждая переменная, функция, класс и т. п. может иметь не более одного определения. Объявлений — сколько угодно (кроме перечислений без заданного базового типа, которые просто нельзя объявить, не определив), но определений — не больше одного. Можно меньше, если сущность не используется.

* В рамках всей программы каждая используемая не-inline функция и переменная обязана иметь строго одно определение. Каждая используемая inline функция и переменная должна иметь одно определение в каждой единице трансляции.

* Некоторые сущности — например классы, inline функции и переменный, шаблоны, перечисления и т. д. — могут иметь несколько определений в программе (но не больше одного в единице трансляции). Собственно это и происходит, когда в несколько .cpp файлов подключается один и тот же заголовок, содержащий полностью реализованный класс, например. Но эти определения должны совпадать (я сильно упрощаю, но суть такова). Иначе будет UB.

Компилятор легко отловит нарушение ODR в рамках единицы трансляции. Но он ничего не сможет сделать, если правило нарушается в масштабе программы — хотя бы потому, что компилятор обрабатывает по одной единице трансляции за раз.

Гораздо больше нарушений может найти линковщик, но, строго говоря, он не обязан этого делать (т. к. по Стандарту тут UB) и что-то может пропустить. К тому же процесс поиска нарушений ODR на этапе линковки имеет квадратичную сложность, а сборка C++ кода и так не быстрая.

В итоге главным ответственным за соблюдение этого правила (особенно в масштабе программы) является сам разработчик. И да — нарушить ODR на масштабе программы могут только сущности с внешней линковкой; те, что с внутренней (т. е. определенные в анонимных неймспейсах), в этом карнавале не участвуют.
