### NVI

https://habr.com/ru/post/470265/

*Non-Virtual Interface. Невиртуальный интерфейс.* Согласно этой идиоме открытый интерфейс класса не должен содержать виртуальных функций. Все виртуальные функции делаются закрытыми (максимум защищенными) и вызываются внутри открытых невиртуальных.

Пример

```c++
class Base
{
public:
    virtual ~Base() = default;

    void foo()
    {
        // check precondition
        fooImpl();
        // check postconditions
    }

protected:
    virtual void fooImpl() = 0;
};

class Derived : public Base
{
protected:
    void fooImpl() override
    {
    }
};
```

Зачем это надо:

* Каждая открытая виртуальная функция делает 2 вещи: определяет открытый интерфейс класса и участвует в переопределении поведения в классах-потомках. Применение NVI избавляет от таких функций с двойной нагрузкой: интерфейс задается одними функциями, изменение поведения — другими. Можно менять и то, и другое независимо друг от друга.
* Если для всех вариантов реализации виртуальной функции есть некие общие требования (пред- и пост-проверки, захват мьютекса и т. п.), то очень удобно собрать их в одном месте (см. DRY) — в базовом классе — и запретить наследникам переопределять это поведение. Т.е. получается частный случай паттерна Шаблонный метод.

Плата за использование NVI – некоторое разбухание кода, возможное снижение производительности (из-за одного дополнительного вызова метода) и повышенная подверженность проблеме хрупкого базового класса (см. FBC).