### ABA

https://habr.com/ru/post/470317/

*A-B-A problem. Проблема A-B-A.* Эта проблема возникает в параллельных алгоритмах, основанных на сравнении с обменом (см. CAS), например, в свободных от блокировок алгоримах. Суть в том, что поток читает значение атомарной переменной, делает что-то еще и обновляет эту переменную через сравнение с обменом. Т.е. логика потока такова: если переменная все еще содержит прежнее значение, значит ничего не изменилось, все в порядке. Но это может быть и не так. Более формальное описание проблемы:

* поток 1 читает значение переменной, оно равно A
* поток 1 вытесняется, начинает работу поток 2
* поток 2 меняет значение переменной с A на B, делает кучу изменений (меняет какое-то значение, ассоциируемое с переменной или просто освобождает память), а потом опять меняет значение — c B на A
* поток 1 возобновляет работу, сравнивает полученное ранее значение с текущим и делает вывод, что ничего не изменилось

Возможные решения проблемы:

* Самое простое и очевидное — использовать блокировки. Получится обычный потоко-безопасный алгоритм с критическими секциями. Но он перестанет быть свободным от блокировок. Но если дело дошло до CAS и ABA, то это скорее всего не вариант.
* Добавить специальные метки в сравниваемые значения. Например, счетчик числа изменений. С одной стороны, этот счетчик может переполниться, но с другой — современные x86_64 процессоры поддерживают 128-битные CAS операции. Т.е. при сравнении указателей под счетчик можно отдать до 64 бит, и кто-то прикинул, что этого хватит на 10 лет непрерывной работы алгоритма.
* Некоторые архитектуры (ARM, например) предоставляют инструкции LL/SC (load linked, store conditional), которые позволяют не только получить текущее значение адреса в памяти, но понять, были ли это значение изменено со времени последнего чтения.

Для применения в свободных от блокировок структур данных типа стека, списка, очереди — в общем там, где есть риск остаться с висящим указателем на удаленный узел — есть целое семейство решений проблемы ABA, основанное на отложенном удалении узлов. К нему относятся сборщик мусора, указатели опасности (hazard pointers) и механизм чтение-модификация-запись (см. RCU).
