### ABI

https://habr.com/ru/post/470317/

*Application Binary Interface. Бинарный интерфейс приложений.* Это набор соглашений, определяющий взаимодействие бинарных модулей (исполняемых файлов, библиотек, ОС). Два модуля должны быть созданы с соблюдением одного ABI – это является необходимым условием их бинарной совместимости, в этом случае они могут взаимодействовать без проблем (например, исполняемый файл линковаться с библиотекой и выполняться операционной системой).

Примерами ABI являются форматы исполняемых файлов ELF в Linux и PE в Windows. Каждая ОС ожидает, что нужные данные (ресурсы, точка входа, etc.) расположены в бинарном файле согласно соответствующему формату. Очевидно, ELF и PE различаются, потому линуксовые программы не запускаются напрямую на винде и наоборот.

На уровне библиотек и исполняемых файлов ABI может определять размещение полей внутри класса, базовых классов внутри потомков, механизм реализации виртуальных функций, формат фрейма стека вызовов, правила передачи аргументов в вызываемую функцию, и т. д. и т. п.

У C++ нет единого стандартного ABI, что неудивительно, т. к. он зависит от архитектуры и ОС. Например, компиляторы C++ для многих Unix-подобных ОС (Linux, FreeBSD, MacOS) на x86_64 следуют System V AMD64 ABI, на ARM – ARM C++ ABI. Visual C++ ABI официально не опубликован, но как минимум частично отреверсинженирен. Он сильно отличается от System V ABI, у них совершенно разные правила сокрытия имен (mangling) и передачи аргументов в вызываемую функцию (в Linux используются 6 регистров, в Windows – 4), и куча других отличий.

Даже если API и ABI остаются прежними, а меняются только детали реализации, бинарная совместимость может нарушаться. Например в C++11 появилось требование к строкам хранить символы последовательно (как в векторе). Из-за этого GCC 5 пришлось изменить реализацию строк (раньше там использовался COW), что привело к бинарной несовместимости.
